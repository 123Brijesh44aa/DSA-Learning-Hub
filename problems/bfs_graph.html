<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breadth-First Search (BFS) Explained</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;700&family=Ubuntu+Mono&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Ubuntu', sans-serif;
        }

        body {
            background: #2e2e2e;
            color: #e0e0e0;
            line-height: 1.6;
        }

        .container {
            width: 100%;
            min-height: 100vh;
            padding: 20px;
            background: #1c2526;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        h1,
        h2,
        h3 {
            color: #00ff00;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5em;
            text-align: center;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            font-size: 1.1em;
            padding: 0 15px;
        }

        .code-block {
            background: #282c34;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 15px;
            font-family: 'Ubuntu Mono', monospace;
            font-size: 0.95em;
            overflow-x: auto;
        }

        .code-block code {
            color: #abb2bf;
        }

        .code-block .keyword {
            color: #c678dd;
        }

        .code-block .string {
            color: #98c379;
        }

        .code-block .comment {
            color: #5c6370;
        }

        .code-block .number {
            color: #d19a66;
        }

        .example {
            background: #353b48;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 15px;
        }

        .example h3 {
            color: #61afef;
        }

        .step {
            margin: 15px 0;
            padding-left: 20px;
            border-left: 3px solid #00ff00;
        }

        button {
            background: #00ff00;
            color: #1c2526;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin: 10px 15px;
            transition: background 0.2s;
        }

        button:hover {
            background: #00cc00;
        }

        .output {
            background: #282c34;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 15px;
            display: none;
        }

        .output.active {
            display: block;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
            }

            p,
            .code-block,
            .example,
            button,
            .output {
                margin-left: 10px;
                margin-right: 10px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Breadth-First Search (BFS) Explained</h1>

        <section>
            <h2>What is BFS?</h2>
            <p>Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbors.</p>
        </section>

        <section>
            <h2>How Does BFS Work?</h2>
            <p>Here’s the step-by-step process:</p>
            <div class="step">
                <p><strong>1. Initialize:</strong> Use a Queue to keep track of nodes to visit. Add the starting node to the queue and mark it as visited.</p>
                <p><strong>2. Iterate:</strong> While the queue is not empty:</p>
                <ul>
                    <li>Dequeue a node.</li>
                    <li>Process the node (e.g., print it).</li>
                    <li>Enqueue all its unvisited neighbors and mark them as visited.</li>
                </ul>
                <p><strong>3. Repeat</strong> until the queue is empty.</p>
            </div>
        </section>

        <section>
            <h2>Complexity Analysis</h2>
            <p><strong>Time Complexity:</strong> O(V + E), where V is the number of vertices and E is the number of edges.</p>
            <p><strong>Space Complexity:</strong> O(V), since in the worst case, we might need to store all vertices in the queue.</p>
        </section>

        <section>
            <h2>Code Implementation in Java</h2>
            <p>Here’s a Java implementation of BFS using an Adjacency List:</p>
            <div class="code-block">
                <code>
                    <span class="keyword">import</span> java.util.*;<br>
                    <br>
                    <span class="keyword">class</span> Graph {<br>
                        <span class="keyword">private int</span> V;   <span class="comment">// No. of vertices</span><br>
                        <span class="keyword">private</span> LinkedList<Integer> adj[]; <span class="comment">// Adjacency Lists</span><br>
                        <br>
                        <span class="comment">// Constructor</span><br>
                        Graph(<span class="keyword">int</span> v) {<br>
                            V = v;<br>
                            adj = <span class="keyword">new</span> LinkedList[v];<br>
                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < v; ++i)<br>
                                adj[i] = <span class="keyword">new</span> LinkedList();<br>
                        }<br>
                        <br>
                        <span class="comment">// Function to add an edge into the graph</span><br>
                        <span class="keyword">void</span> addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w) {<br>
                            adj[v].add(w);<br>
                        }<br>
                        <br>
                        <span class="comment">// prints BFS traversal from a given source s</span><br>
                        <span class="keyword">void</span> BFS(<span class="keyword">int</span> s) {<br>
                            <span class="comment">// Mark all the vertices as not visited(By default set as false)</span><br>
                            <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V];<br>
                            <br>
                            <span class="comment">// Create a queue for BFS</span><br>
                            LinkedList<Integer> queue = <span class="keyword">new</span> LinkedList<Integer>();<br>
                            <br>
                            <span class="comment">// Mark the current node as visited and enqueue it</span><br>
                            visited[s] = <span class="keyword">true</span>;<br>
                            queue.add(s);<br>
                            <br>
                            <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) {<br>
                                <span class="comment">// Dequeue a vertex from queue and print it</span><br>
                                s = queue.poll();<br>
                                System.out.print(s + <span class="string">" "</span>);<br>
                                <br>
                                <span class="comment">// Get all adjacent vertices of the dequeued vertex s</span><br>
                                <span class="comment">// If a adjacent has not been visited, then mark it</span><br>
                                <span class="comment">// visited and enqueue it</span><br>
                                Iterator<Integer> i = adj[s].listIterator();<br>
                                <span class="keyword">while</span> (i.hasNext()) {<br>
                                    <span class="keyword">int</span> n = i.next();<br>
                                    <span class="keyword">if</span> (!visited[n]) {<br>
                                        visited[n] = <span class="keyword">true</span>;<br>
                                        queue.add(n);<br>
                                    }<br>
                                }<br>
                            }<br>
                        }<br>
                    }
                </code>
            </div>
        </section>

        <section>
            <h2>Examples</h2>

            <div class="example">
                <h3>Example 1: BFS Traversal</h3>
                <p>Start Node: 2</p>
                <p>Graph Edges: (0->1), (0->2), (1->2), (2->0), (2->3), (3->3)</p>
                <p>Steps:</p>
                <ul>
                    <li>Queue: [2], Visited: {2}</li>
                    <li>Dequeue 2, print 2. Neighbors of 2: 0, 3.</li>
                    <li>Enqueue 0, 3. Queue: [0, 3], Visited: {2, 0, 3}</li>
                    <li>Dequeue 0, print 0. Neighbors of 0: 1, 2.</li>
                    <li>2 is visited. Enqueue 1. Queue: [3, 1], Visited: {2, 0, 3, 1}</li>
                    <li>Dequeue 3, print 3. Neighbors of 3: 3. Visited.</li>
                    <li>Dequeue 1, print 1. Neighbors of 1: 2. Visited.</li>
                    <li>Queue empty. End.</li>
                </ul>
                <button onclick="showOutput('output1')">Run Example</button>
                <div id="output1" class="output">
                    <p>Output: 2 0 3 1</p>
                </div>
            </div>
        </section>
    </div>

    <script>
        function showOutput(outputId) {
            const output = document.getElementById(outputId);
            output.classList.toggle('active');
        }
    </script>
</body>

</html>